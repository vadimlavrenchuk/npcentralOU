import { n as __commonJS, r as __toESM, t as require_react } from "./react-CcqPggiU.js";

//#region node_modules/@babel/runtime/helpers/esm/extends.js
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
function _extends() {
	return _extends = Object.assign ? Object.assign.bind() : function(n$1) {
		for (var e$1 = 1; e$1 < arguments.length; e$1++) {
			var t$1 = arguments[e$1];
			for (var r$1 in t$1) ({}).hasOwnProperty.call(t$1, r$1) && (n$1[r$1] = t$1[r$1]);
		}
		return n$1;
	}, _extends.apply(null, arguments);
}

//#endregion
//#region node_modules/void-elements/index.js
var require_void_elements = /* @__PURE__ */ __commonJS({ "node_modules/void-elements/index.js": ((exports, module) => {
	/**
	* This file automatically generated from `pre-publish.js`.
	* Do not manually edit.
	*/
	module.exports = {
		"area": true,
		"base": true,
		"br": true,
		"col": true,
		"embed": true,
		"hr": true,
		"img": true,
		"input": true,
		"link": true,
		"meta": true,
		"param": true,
		"source": true,
		"track": true,
		"wbr": true
	};
}) });

//#endregion
//#region node_modules/html-parse-stringify/dist/html-parse-stringify.module.js
var import_void_elements = /* @__PURE__ */ __toESM(require_void_elements());
var t = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
function n(n$1) {
	var r$1 = {
		type: "tag",
		name: "",
		voidElement: !1,
		attrs: {},
		children: []
	}, i$1 = n$1.match(/<\/?([^\s]+?)[/\s>]/);
	if (i$1 && (r$1.name = i$1[1], (import_void_elements.default[i$1[1]] || "/" === n$1.charAt(n$1.length - 2)) && (r$1.voidElement = !0), r$1.name.startsWith("!--"))) {
		var s$1 = n$1.indexOf("-->");
		return {
			type: "comment",
			comment: -1 !== s$1 ? n$1.slice(4, s$1) : ""
		};
	}
	for (var a$1 = new RegExp(t), c$1 = null; null !== (c$1 = a$1.exec(n$1));) if (c$1[0].trim()) if (c$1[1]) {
		var o = c$1[1].trim(), l = [o, ""];
		o.indexOf("=") > -1 && (l = o.split("=")), r$1.attrs[l[0]] = l[1], a$1.lastIndex--;
	} else c$1[2] && (r$1.attrs[c$1[2]] = c$1[3].trim().substring(1, c$1[3].length - 1));
	return r$1;
}
var r = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g, i = /^\s*$/, s = Object.create(null);
function a(e$1, t$1) {
	switch (t$1.type) {
		case "text": return e$1 + t$1.content;
		case "tag": return e$1 += "<" + t$1.name + (t$1.attrs ? function(e$2) {
			var t$2 = [];
			for (var n$1 in e$2) t$2.push(n$1 + "=\"" + e$2[n$1] + "\"");
			return t$2.length ? " " + t$2.join(" ") : "";
		}(t$1.attrs) : "") + (t$1.voidElement ? "/>" : ">"), t$1.voidElement ? e$1 : e$1 + t$1.children.reduce(a, "") + "</" + t$1.name + ">";
		case "comment": return e$1 + "<!--" + t$1.comment + "-->";
	}
}
var c = {
	parse: function(e$1, t$1) {
		t$1 || (t$1 = {}), t$1.components || (t$1.components = s);
		var a$1, c$1 = [], o = [], l = -1, m = !1;
		if (0 !== e$1.indexOf("<")) {
			var u = e$1.indexOf("<");
			c$1.push({
				type: "text",
				content: -1 === u ? e$1 : e$1.substring(0, u)
			});
		}
		return e$1.replace(r, function(r$1, s$1) {
			if (m) {
				if (r$1 !== "</" + a$1.name + ">") return;
				m = !1;
			}
			var u$1, f = "/" !== r$1.charAt(1), h = r$1.startsWith("<!--"), p = s$1 + r$1.length, d = e$1.charAt(p);
			if (h) {
				var v = n(r$1);
				return l < 0 ? (c$1.push(v), c$1) : ((u$1 = o[l]).children.push(v), c$1);
			}
			if (f && (l++, "tag" === (a$1 = n(r$1)).type && t$1.components[a$1.name] && (a$1.type = "component", m = !0), a$1.voidElement || m || !d || "<" === d || a$1.children.push({
				type: "text",
				content: e$1.slice(p, e$1.indexOf("<", p))
			}), 0 === l && c$1.push(a$1), (u$1 = o[l - 1]) && u$1.children.push(a$1), o[l] = a$1), (!f || a$1.voidElement) && (l > -1 && (a$1.voidElement || a$1.name === r$1.slice(2, -1)) && (l--, a$1 = -1 === l ? c$1 : o[l]), !m && "<" !== d && d)) {
				u$1 = -1 === l ? c$1 : o[l].children;
				var x = e$1.indexOf("<", p), g = e$1.slice(p, -1 === x ? void 0 : x);
				i.test(g) && (g = " "), (x > -1 && l + u$1.length >= 0 || " " !== g) && u$1.push({
					type: "text",
					content: g
				});
			}
		}), c$1;
	},
	stringify: function(e$1) {
		return e$1.reduce(function(e$2, t$1) {
			return e$2 + a("", t$1);
		}, "");
	}
};
var html_parse_stringify_module_default = c;

//#endregion
//#region node_modules/react-i18next/dist/es/utils.js
function warn() {
	if (console && console.warn) {
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		if (typeof args[0] === "string") args[0] = `react-i18next:: ${args[0]}`;
		console.warn(...args);
	}
}
var alreadyWarned = {};
function warnOnce() {
	for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
	if (typeof args[0] === "string" && alreadyWarned[args[0]]) return;
	if (typeof args[0] === "string") alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
	warn(...args);
}
var loadedClb = (i18n, cb) => () => {
	if (i18n.isInitialized) cb();
	else {
		const initialized = () => {
			setTimeout(() => {
				i18n.off("initialized", initialized);
			}, 0);
			cb();
		};
		i18n.on("initialized", initialized);
	}
};
function loadNamespaces(i18n, ns, cb) {
	i18n.loadNamespaces(ns, loadedClb(i18n, cb));
}
function loadLanguages(i18n, lng, ns, cb) {
	if (typeof ns === "string") ns = [ns];
	ns.forEach((n$1) => {
		if (i18n.options.ns.indexOf(n$1) < 0) i18n.options.ns.push(n$1);
	});
	i18n.loadLanguages(lng, loadedClb(i18n, cb));
}
function oldI18nextHasLoadedNamespace(ns, i18n) {
	let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
	const lng = i18n.languages[0];
	const fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
	const lastLng = i18n.languages[i18n.languages.length - 1];
	if (lng.toLowerCase() === "cimode") return true;
	const loadNotPending = (l, n$1) => {
		const loadState = i18n.services.backendConnector.state[`${l}|${n$1}`];
		return loadState === -1 || loadState === 2;
	};
	if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns)) return false;
	if (i18n.hasResourceBundle(lng, ns)) return true;
	if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages) return true;
	if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
	return false;
}
function hasLoadedNamespace(ns, i18n) {
	let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
	if (!i18n.languages || !i18n.languages.length) {
		warnOnce("i18n.languages were undefined or empty", i18n.languages);
		return true;
	}
	if (!(i18n.options.ignoreJSONStructure !== void 0)) return oldI18nextHasLoadedNamespace(ns, i18n, options);
	return i18n.hasLoadedNamespace(ns, {
		lng: options.lng,
		precheck: (i18nInstance$1, loadNotPending) => {
			if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance$1.services.backendConnector.backend && i18nInstance$1.isLanguageChangingTo && !loadNotPending(i18nInstance$1.isLanguageChangingTo, ns)) return false;
		}
	});
}
function getDisplayName(Component) {
	return Component.displayName || Component.name || (typeof Component === "string" && Component.length > 0 ? Component : "Unknown");
}

//#endregion
//#region node_modules/react-i18next/dist/es/unescape.js
var matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
var htmlEntities = {
	"&amp;": "&",
	"&#38;": "&",
	"&lt;": "<",
	"&#60;": "<",
	"&gt;": ">",
	"&#62;": ">",
	"&apos;": "'",
	"&#39;": "'",
	"&quot;": "\"",
	"&#34;": "\"",
	"&nbsp;": " ",
	"&#160;": " ",
	"&copy;": "©",
	"&#169;": "©",
	"&reg;": "®",
	"&#174;": "®",
	"&hellip;": "…",
	"&#8230;": "…",
	"&#x2F;": "/",
	"&#47;": "/"
};
var unescapeHtmlEntity = (m) => htmlEntities[m];
const unescape = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);

//#endregion
//#region node_modules/react-i18next/dist/es/defaults.js
var defaultOptions = {
	bindI18n: "languageChanged",
	bindI18nStore: "",
	transEmptyNodeValue: "",
	transSupportBasicHtmlNodes: true,
	transWrapTextNodes: "",
	transKeepBasicHtmlNodesFor: [
		"br",
		"strong",
		"i",
		"p"
	],
	useSuspense: true,
	unescape
};
function setDefaults() {
	let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
	defaultOptions = {
		...defaultOptions,
		...options
	};
}
function getDefaults() {
	return defaultOptions;
}

//#endregion
//#region node_modules/react-i18next/dist/es/i18nInstance.js
var i18nInstance;
function setI18n(instance) {
	i18nInstance = instance;
}
function getI18n() {
	return i18nInstance;
}

//#endregion
//#region node_modules/react-i18next/dist/es/TransWithoutContext.js
function hasChildren(node, checkLength) {
	if (!node) return false;
	const base = node.props ? node.props.children : node.children;
	if (checkLength) return base.length > 0;
	return !!base;
}
function getChildren(node) {
	if (!node) return [];
	const children = node.props ? node.props.children : node.children;
	return node.props && node.props.i18nIsDynamicList ? getAsArray(children) : children;
}
function hasValidReactChildren(children) {
	if (Object.prototype.toString.call(children) !== "[object Array]") return false;
	return children.every((child) => (0, import_react.isValidElement)(child));
}
function getAsArray(data) {
	return Array.isArray(data) ? data : [data];
}
function mergeProps(source, target) {
	const newTarget = { ...target };
	newTarget.props = Object.assign(source.props, target.props);
	return newTarget;
}
function nodesToString(children, i18nOptions) {
	if (!children) return "";
	let stringNode = "";
	const childrenArray = getAsArray(children);
	const keepArray = i18nOptions.transSupportBasicHtmlNodes && i18nOptions.transKeepBasicHtmlNodesFor ? i18nOptions.transKeepBasicHtmlNodesFor : [];
	childrenArray.forEach((child, childIndex) => {
		if (typeof child === "string") stringNode += `${child}`;
		else if ((0, import_react.isValidElement)(child)) {
			const childPropsCount = Object.keys(child.props).length;
			const shouldKeepChild = keepArray.indexOf(child.type) > -1;
			const childChildren = child.props.children;
			if (!childChildren && shouldKeepChild && childPropsCount === 0) stringNode += `<${child.type}/>`;
			else if (!childChildren && (!shouldKeepChild || childPropsCount !== 0)) stringNode += `<${childIndex}></${childIndex}>`;
			else if (child.props.i18nIsDynamicList) stringNode += `<${childIndex}></${childIndex}>`;
			else if (shouldKeepChild && childPropsCount === 1 && typeof childChildren === "string") stringNode += `<${child.type}>${childChildren}</${child.type}>`;
			else {
				const content = nodesToString(childChildren, i18nOptions);
				stringNode += `<${childIndex}>${content}</${childIndex}>`;
			}
		} else if (child === null) warn(`Trans: the passed in value is invalid - seems you passed in a null child.`);
		else if (typeof child === "object") {
			const { format, ...clone } = child;
			const keys = Object.keys(clone);
			if (keys.length === 1) {
				const value = format ? `${keys[0]}, ${format}` : keys[0];
				stringNode += `{{${value}}}`;
			} else warn(`react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.`, child);
		} else warn(`Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.`, child);
	});
	return stringNode;
}
function renderNodes(children, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) {
	if (targetString === "") return [];
	const keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
	const emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.map((keep) => `<${keep}`).join("|")).test(targetString);
	if (!children && !emptyChildrenButNeedsHandling && !shouldUnescape) return [targetString];
	const data = {};
	function getData(childs) {
		getAsArray(childs).forEach((child) => {
			if (typeof child === "string") return;
			if (hasChildren(child)) getData(getChildren(child));
			else if (typeof child === "object" && !(0, import_react.isValidElement)(child)) Object.assign(data, child);
		});
	}
	getData(children);
	const ast = html_parse_stringify_module_default.parse(`<0>${targetString}</0>`);
	const opts = {
		...data,
		...combinedTOpts
	};
	function renderInner(child, node, rootReactNode) {
		const childs = getChildren(child);
		const mappedChildren = mapAST(childs, node.children, rootReactNode);
		return hasValidReactChildren(childs) && mappedChildren.length === 0 || child.props && child.props.i18nIsDynamicList ? childs : mappedChildren;
	}
	function pushTranslatedJSX(child, inner, mem, i$1, isVoid) {
		if (child.dummy) {
			child.children = inner;
			mem.push((0, import_react.cloneElement)(child, { key: i$1 }, isVoid ? void 0 : inner));
		} else mem.push(...import_react.Children.map([child], (c$1) => {
			const props = { ...c$1.props };
			delete props.i18nIsDynamicList;
			return import_react.createElement(c$1.type, _extends({}, props, {
				key: i$1,
				ref: c$1.ref
			}, isVoid ? {} : { children: inner }));
		}));
	}
	function mapAST(reactNode, astNode, rootReactNode) {
		const reactNodes = getAsArray(reactNode);
		return getAsArray(astNode).reduce((mem, node, i$1) => {
			const translationContent = node.children && node.children[0] && node.children[0].content && i18n.services.interpolator.interpolate(node.children[0].content, opts, i18n.language);
			if (node.type === "tag") {
				let tmp = reactNodes[parseInt(node.name, 10)];
				if (rootReactNode.length === 1 && !tmp) tmp = rootReactNode[0][node.name];
				if (!tmp) tmp = {};
				const child = Object.keys(node.attrs).length !== 0 ? mergeProps({ props: node.attrs }, tmp) : tmp;
				const isElement = (0, import_react.isValidElement)(child);
				const isValidTranslationWithChildren = isElement && hasChildren(node, true) && !node.voidElement;
				const isEmptyTransWithHTML = emptyChildrenButNeedsHandling && typeof child === "object" && child.dummy && !isElement;
				const isKnownComponent = typeof children === "object" && children !== null && Object.hasOwnProperty.call(children, node.name);
				if (typeof child === "string") {
					const value = i18n.services.interpolator.interpolate(child, opts, i18n.language);
					mem.push(value);
				} else if (hasChildren(child) || isValidTranslationWithChildren) pushTranslatedJSX(child, renderInner(child, node, rootReactNode), mem, i$1);
				else if (isEmptyTransWithHTML) pushTranslatedJSX(child, mapAST(reactNodes, node.children, rootReactNode), mem, i$1);
				else if (Number.isNaN(parseFloat(node.name))) if (isKnownComponent) pushTranslatedJSX(child, renderInner(child, node, rootReactNode), mem, i$1, node.voidElement);
				else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) if (node.voidElement) mem.push((0, import_react.createElement)(node.name, { key: `${node.name}-${i$1}` }));
				else {
					const inner = mapAST(reactNodes, node.children, rootReactNode);
					mem.push((0, import_react.createElement)(node.name, { key: `${node.name}-${i$1}` }, inner));
				}
				else if (node.voidElement) mem.push(`<${node.name} />`);
				else {
					const inner = mapAST(reactNodes, node.children, rootReactNode);
					mem.push(`<${node.name}>${inner}</${node.name}>`);
				}
				else if (typeof child === "object" && !isElement) {
					const content = node.children[0] ? translationContent : null;
					if (content) mem.push(content);
				} else pushTranslatedJSX(child, translationContent, mem, i$1, node.children.length !== 1 || !translationContent);
			} else if (node.type === "text") {
				const wrapTextNodes = i18nOptions.transWrapTextNodes;
				const content = shouldUnescape ? i18nOptions.unescape(i18n.services.interpolator.interpolate(node.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node.content, opts, i18n.language);
				if (wrapTextNodes) mem.push((0, import_react.createElement)(wrapTextNodes, { key: `${node.name}-${i$1}` }, content));
				else mem.push(content);
			}
			return mem;
		}, []);
	}
	return getChildren(mapAST([{
		dummy: true,
		children: children || []
	}], ast, getAsArray(children || []))[0]);
}
function Trans$1(_ref) {
	let { children, count, parent, i18nKey, context, tOptions = {}, values, defaults, components, ns, i18n: i18nFromProps, t: tFromProps, shouldUnescape, ...additionalProps } = _ref;
	const i18n = i18nFromProps || getI18n();
	if (!i18n) {
		warnOnce("You will need to pass in an i18next instance by using i18nextReactModule");
		return children;
	}
	const t$1 = tFromProps || i18n.t.bind(i18n) || ((k) => k);
	if (context) tOptions.context = context;
	const reactI18nextOptions = {
		...getDefaults(),
		...i18n.options && i18n.options.react
	};
	let namespaces = ns || t$1.ns || i18n.options && i18n.options.defaultNS;
	namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
	const nodeAsString = nodesToString(children, reactI18nextOptions);
	const defaultValue = defaults || nodeAsString || reactI18nextOptions.transEmptyNodeValue || i18nKey;
	const { hashTransKey } = reactI18nextOptions;
	const key = i18nKey || (hashTransKey ? hashTransKey(nodeAsString || defaultValue) : nodeAsString || defaultValue);
	if (i18n.options && i18n.options.interpolation && i18n.options.interpolation.defaultVariables) values = values && Object.keys(values).length > 0 ? {
		...values,
		...i18n.options.interpolation.defaultVariables
	} : { ...i18n.options.interpolation.defaultVariables };
	const interpolationOverride = values ? tOptions.interpolation : { interpolation: {
		...tOptions.interpolation,
		prefix: "#$?",
		suffix: "?$#"
	} };
	const combinedTOpts = {
		...tOptions,
		count,
		...values,
		...interpolationOverride,
		defaultValue,
		ns: namespaces
	};
	const translation = key ? t$1(key, combinedTOpts) : defaultValue;
	if (components) Object.keys(components).forEach((c$1) => {
		const comp = components[c$1];
		if (typeof comp.type === "function" || !comp.props || !comp.props.children || translation.indexOf(`${c$1}/>`) < 0 && translation.indexOf(`${c$1} />`) < 0) return;
		function Componentized() {
			return import_react.createElement(import_react.Fragment, null, comp);
		}
		components[c$1] = import_react.createElement(Componentized, null);
	});
	const content = renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts, shouldUnescape);
	const useAsParent = parent !== void 0 ? parent : reactI18nextOptions.defaultTransParent;
	return useAsParent ? (0, import_react.createElement)(useAsParent, additionalProps, content) : content;
}

//#endregion
//#region node_modules/react-i18next/dist/es/initReactI18next.js
const initReactI18next = {
	type: "3rdParty",
	init(instance) {
		setDefaults(instance.options.react);
		setI18n(instance);
	}
};

//#endregion
//#region node_modules/react-i18next/dist/es/context.js
const I18nContext = (0, import_react.createContext)();
var ReportNamespaces = class {
	constructor() {
		this.usedNamespaces = {};
	}
	addUsedNamespaces(namespaces) {
		namespaces.forEach((ns) => {
			if (!this.usedNamespaces[ns]) this.usedNamespaces[ns] = true;
		});
	}
	getUsedNamespaces() {
		return Object.keys(this.usedNamespaces);
	}
};
function composeInitialProps(ForComponent) {
	return (ctx) => new Promise((resolve) => {
		const i18nInitialProps = getInitialProps();
		if (ForComponent.getInitialProps) ForComponent.getInitialProps(ctx).then((componentsInitialProps) => {
			resolve({
				...componentsInitialProps,
				...i18nInitialProps
			});
		});
		else resolve(i18nInitialProps);
	});
}
function getInitialProps() {
	const i18n = getI18n();
	const namespaces = i18n.reportNamespaces ? i18n.reportNamespaces.getUsedNamespaces() : [];
	const ret = {};
	const initialI18nStore = {};
	i18n.languages.forEach((l) => {
		initialI18nStore[l] = {};
		namespaces.forEach((ns) => {
			initialI18nStore[l][ns] = i18n.getResourceBundle(l, ns) || {};
		});
	});
	ret.initialI18nStore = initialI18nStore;
	ret.initialLanguage = i18n.language;
	return ret;
}

//#endregion
//#region node_modules/react-i18next/dist/es/Trans.js
function Trans(_ref) {
	let { children, count, parent, i18nKey, context, tOptions = {}, values, defaults, components, ns, i18n: i18nFromProps, t: tFromProps, shouldUnescape, ...additionalProps } = _ref;
	const { i18n: i18nFromContext, defaultNS: defaultNSFromContext } = (0, import_react.useContext)(I18nContext) || {};
	const i18n = i18nFromProps || i18nFromContext || getI18n();
	const t$1 = tFromProps || i18n && i18n.t.bind(i18n);
	return Trans$1({
		children,
		count,
		parent,
		i18nKey,
		context,
		tOptions,
		values,
		defaults,
		components,
		ns: ns || t$1 && t$1.ns || defaultNSFromContext || i18n && i18n.options && i18n.options.defaultNS,
		i18n,
		t: tFromProps,
		shouldUnescape,
		...additionalProps
	});
}

//#endregion
//#region node_modules/react-i18next/dist/es/useTranslation.js
var usePrevious = (value, ignore) => {
	const ref = (0, import_react.useRef)();
	(0, import_react.useEffect)(() => {
		ref.current = ignore ? ref.current : value;
	}, [value, ignore]);
	return ref.current;
};
function useTranslation(ns) {
	let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	const { i18n: i18nFromProps } = props;
	const { i18n: i18nFromContext, defaultNS: defaultNSFromContext } = (0, import_react.useContext)(I18nContext) || {};
	const i18n = i18nFromProps || i18nFromContext || getI18n();
	if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();
	if (!i18n) {
		warnOnce("You will need to pass in an i18next instance by using initReactI18next");
		const notReadyT = (k, optsOrDefaultValue) => {
			if (typeof optsOrDefaultValue === "string") return optsOrDefaultValue;
			if (optsOrDefaultValue && typeof optsOrDefaultValue === "object" && typeof optsOrDefaultValue.defaultValue === "string") return optsOrDefaultValue.defaultValue;
			return Array.isArray(k) ? k[k.length - 1] : k;
		};
		const retNotReady = [
			notReadyT,
			{},
			false
		];
		retNotReady.t = notReadyT;
		retNotReady.i18n = {};
		retNotReady.ready = false;
		return retNotReady;
	}
	if (i18n.options.react && i18n.options.react.wait !== void 0) warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
	const i18nOptions = {
		...getDefaults(),
		...i18n.options.react,
		...props
	};
	const { useSuspense, keyPrefix } = i18nOptions;
	let namespaces = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
	namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
	if (i18n.reportNamespaces.addUsedNamespaces) i18n.reportNamespaces.addUsedNamespaces(namespaces);
	const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n$1) => hasLoadedNamespace(n$1, i18n, i18nOptions));
	function getT() {
		return i18n.getFixedT(props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
	}
	const [t$1, setT] = (0, import_react.useState)(getT);
	let joinedNS = namespaces.join();
	if (props.lng) joinedNS = `${props.lng}${joinedNS}`;
	const previousJoinedNS = usePrevious(joinedNS);
	const isMounted = (0, import_react.useRef)(true);
	(0, import_react.useEffect)(() => {
		const { bindI18n, bindI18nStore } = i18nOptions;
		isMounted.current = true;
		if (!ready && !useSuspense) if (props.lng) loadLanguages(i18n, props.lng, namespaces, () => {
			if (isMounted.current) setT(getT);
		});
		else loadNamespaces(i18n, namespaces, () => {
			if (isMounted.current) setT(getT);
		});
		if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) setT(getT);
		function boundReset() {
			if (isMounted.current) setT(getT);
		}
		if (bindI18n && i18n) i18n.on(bindI18n, boundReset);
		if (bindI18nStore && i18n) i18n.store.on(bindI18nStore, boundReset);
		return () => {
			isMounted.current = false;
			if (bindI18n && i18n) bindI18n.split(" ").forEach((e$1) => i18n.off(e$1, boundReset));
			if (bindI18nStore && i18n) bindI18nStore.split(" ").forEach((e$1) => i18n.store.off(e$1, boundReset));
		};
	}, [i18n, joinedNS]);
	const isInitial = (0, import_react.useRef)(true);
	(0, import_react.useEffect)(() => {
		if (isMounted.current && !isInitial.current) setT(getT);
		isInitial.current = false;
	}, [i18n, keyPrefix]);
	const ret = [
		t$1,
		i18n,
		ready
	];
	ret.t = t$1;
	ret.i18n = i18n;
	ret.ready = ready;
	if (ready) return ret;
	if (!ready && !useSuspense) return ret;
	throw new Promise((resolve) => {
		if (props.lng) loadLanguages(i18n, props.lng, namespaces, () => resolve());
		else loadNamespaces(i18n, namespaces, () => resolve());
	});
}

//#endregion
//#region node_modules/react-i18next/dist/es/withTranslation.js
function withTranslation(ns) {
	let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	return function Extend(WrappedComponent) {
		function I18nextWithTranslation(_ref) {
			let { forwardedRef, ...rest } = _ref;
			const [t$1, i18n, ready] = useTranslation(ns, {
				...rest,
				keyPrefix: options.keyPrefix
			});
			const passDownProps = {
				...rest,
				t: t$1,
				i18n,
				tReady: ready
			};
			if (options.withRef && forwardedRef) passDownProps.ref = forwardedRef;
			else if (!options.withRef && forwardedRef) passDownProps.forwardedRef = forwardedRef;
			return (0, import_react.createElement)(WrappedComponent, passDownProps);
		}
		I18nextWithTranslation.displayName = `withI18nextTranslation(${getDisplayName(WrappedComponent)})`;
		I18nextWithTranslation.WrappedComponent = WrappedComponent;
		const forwardRef = (props, ref) => (0, import_react.createElement)(I18nextWithTranslation, Object.assign({}, props, { forwardedRef: ref }));
		return options.withRef ? (0, import_react.forwardRef)(forwardRef) : I18nextWithTranslation;
	};
}

//#endregion
//#region node_modules/react-i18next/dist/es/Translation.js
function Translation(props) {
	const { ns, children, ...options } = props;
	const [t$1, i18n, ready] = useTranslation(ns, options);
	return children(t$1, {
		i18n,
		lng: i18n.language
	}, ready);
}

//#endregion
//#region node_modules/react-i18next/dist/es/I18nextProvider.js
function I18nextProvider(_ref) {
	let { i18n, defaultNS, children } = _ref;
	const value = (0, import_react.useMemo)(() => ({
		i18n,
		defaultNS
	}), [i18n, defaultNS]);
	return (0, import_react.createElement)(I18nContext.Provider, { value }, children);
}

//#endregion
//#region node_modules/react-i18next/dist/es/useSSR.js
function useSSR(initialI18nStore, initialLanguage) {
	const { i18n: i18nFromProps } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
	const { i18n: i18nFromContext } = (0, import_react.useContext)(I18nContext) || {};
	const i18n = i18nFromProps || i18nFromContext || getI18n();
	if (i18n.options && i18n.options.isClone) return;
	if (initialI18nStore && !i18n.initializedStoreOnce) {
		i18n.services.resourceStore.data = initialI18nStore;
		i18n.options.ns = Object.values(initialI18nStore).reduce((mem, lngResources) => {
			Object.keys(lngResources).forEach((ns) => {
				if (mem.indexOf(ns) < 0) mem.push(ns);
			});
			return mem;
		}, i18n.options.ns);
		i18n.initializedStoreOnce = true;
		i18n.isInitialized = true;
	}
	if (initialLanguage && !i18n.initializedLanguageOnce) {
		i18n.changeLanguage(initialLanguage);
		i18n.initializedLanguageOnce = true;
	}
}

//#endregion
//#region node_modules/react-i18next/dist/es/withSSR.js
function withSSR() {
	return function Extend(WrappedComponent) {
		function I18nextWithSSR(_ref) {
			let { initialI18nStore, initialLanguage, ...rest } = _ref;
			useSSR(initialI18nStore, initialLanguage);
			return (0, import_react.createElement)(WrappedComponent, { ...rest });
		}
		I18nextWithSSR.getInitialProps = composeInitialProps(WrappedComponent);
		I18nextWithSSR.displayName = `withI18nextSSR(${getDisplayName(WrappedComponent)})`;
		I18nextWithSSR.WrappedComponent = WrappedComponent;
		return I18nextWithSSR;
	};
}

//#endregion
//#region node_modules/react-i18next/dist/es/index.js
const date = () => "";
const time = () => "";
const number = () => "";
const select = () => "";
const plural = () => "";
const selectOrdinal = () => "";

//#endregion
export { I18nContext, I18nextProvider, Trans, Trans$1 as TransWithoutContext, Translation, composeInitialProps, date, getDefaults, getI18n, getInitialProps, initReactI18next, number, plural, select, selectOrdinal, setDefaults, setI18n, time, useSSR, useTranslation, withSSR, withTranslation };
//# sourceMappingURL=react-i18next.js.map